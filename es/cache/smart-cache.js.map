{"version":3,"file":"smart-cache.js","sources":["../../src/cache/smart-cache.ts"],"sourcesContent":["/**\n * 智能缓存策略\n * 提供基于访问模式的预测性缓存和自适应TTL\n */\n\nimport type { CacheManager } from './cache-manager'\nimport type { Logger } from '../types'\n\n// 访问模式\ninterface AccessPattern {\n  key: string\n  accessCount: number\n  lastAccess: number\n  firstAccess: number\n  averageInterval: number // 平均访问间隔\n  trend: 'increasing' | 'stable' | 'decreasing'\n  predictedNextAccess: number // 预测下次访问时间\n}\n\n// 智能缓存配置\nexport interface SmartCacheConfig {\n  enablePatternLearning?: boolean // 启用模式学习\n  enablePredictivePrefetch?: boolean // 启用预测性预取\n  enableAdaptiveTTL?: boolean // 启用自适应TTL\n  minAccessForPrediction?: number // 预测所需的最小访问次数\n  patternWindow?: number // 模式分析时间窗口（ms）\n  prefetchThreshold?: number // 预取置信度阈值（0-1）\n}\n\n/**\n * 智能缓存策略实现\n */\nexport class SmartCacheStrategy<T = unknown> {\n  private accessPatterns = new Map<string, AccessPattern>()\n  private config: Required<SmartCacheConfig>\n  private predictionTimer?: NodeJS.Timeout\n  private cleanupTimer?: NodeJS.Timeout\n\n  constructor(\n    private cache: CacheManager<T>,\n    config: SmartCacheConfig = {},\n    private logger?: Logger\n  ) {\n    this.config = {\n      enablePatternLearning: config.enablePatternLearning ?? true,\n      enablePredictivePrefetch: config.enablePredictivePrefetch ?? true,\n      enableAdaptiveTTL: config.enableAdaptiveTTL ?? true,\n      minAccessForPrediction: config.minAccessForPrediction || 3,\n      patternWindow: config.patternWindow || 10 * 60 * 1000, // 10分钟\n      prefetchThreshold: config.prefetchThreshold || 0.7\n    }\n\n    // 启动预测引擎\n    if (this.config.enablePredictivePrefetch) {\n      this.startPredictionEngine()\n    }\n\n    // 启动模式清理\n    this.startPatternCleanup()\n  }\n\n  /**\n   * 记录访问模式\n   */\n  recordAccess(key: string): void {\n    if (!this.config.enablePatternLearning) {\n      return\n    }\n\n    const now = Date.now()\n    let pattern = this.accessPatterns.get(key)\n\n    if (!pattern) {\n      pattern = {\n        key,\n        accessCount: 0,\n        lastAccess: now,\n        firstAccess: now,\n        averageInterval: 0,\n        trend: 'stable',\n        predictedNextAccess: 0\n      }\n      this.accessPatterns.set(key, pattern)\n    }\n\n    // 更新访问统计\n    const interval = now - pattern.lastAccess\n    pattern.accessCount++\n    pattern.lastAccess = now\n\n    // 计算平均间隔（指数移动平均）\n    if (pattern.accessCount > 1) {\n      pattern.averageInterval = pattern.averageInterval === 0\n        ? interval\n        : pattern.averageInterval * 0.7 + interval * 0.3\n    }\n\n    // 分析趋势\n    this.analyzeTrend(pattern)\n\n    // 预测下次访问\n    if (pattern.accessCount >= this.config.minAccessForPrediction) {\n      pattern.predictedNextAccess = now + pattern.averageInterval\n    }\n\n    this.logger?.debug(`Access pattern updated for ${key}`, {\n      count: pattern.accessCount,\n      interval: pattern.averageInterval.toFixed(0)\n    })\n  }\n\n  /**\n   * 分析访问趋势\n   */\n  private analyzeTrend(pattern: AccessPattern): void {\n    if (pattern.accessCount < 5) {\n      pattern.trend = 'stable'\n      return\n    }\n\n    const totalTime = pattern.lastAccess - pattern.firstAccess\n    const expectedAccesses = totalTime / pattern.averageInterval\n    const actualAccesses = pattern.accessCount\n\n    const ratio = actualAccesses / expectedAccesses\n\n    if (ratio > 1.2) {\n      pattern.trend = 'increasing'\n    } else if (ratio < 0.8) {\n      pattern.trend = 'decreasing'\n    } else {\n      pattern.trend = 'stable'\n    }\n  }\n\n  /**\n   * 计算自适应TTL\n   */\n  calculateAdaptiveTTL(key: string, defaultTTL: number): number {\n    if (!this.config.enableAdaptiveTTL) {\n      return defaultTTL\n    }\n\n    const pattern = this.accessPatterns.get(key)\n    if (!pattern || pattern.accessCount < this.config.minAccessForPrediction) {\n      return defaultTTL\n    }\n\n    // 根据访问间隔调整TTL\n    // 频繁访问的项使用较短TTL（保持新鲜）\n    // 不常访问的项使用较长TTL（节省资源）\n    if (pattern.averageInterval < 60000) {\n      // 1分钟内频繁访问\n      return Math.max(pattern.averageInterval * 2, 30000)\n    } else if (pattern.averageInterval < 300000) {\n      // 5分钟内中等频率\n      return Math.max(pattern.averageInterval * 1.5, 60000)\n    } else {\n      // 低频访问\n      return Math.min(pattern.averageInterval * 2, defaultTTL * 2)\n    }\n  }\n\n  /**\n   * 获取预测性预取建议\n   */\n  getPrefetchCandidates(): string[] {\n    if (!this.config.enablePredictivePrefetch) {\n      return []\n    }\n\n    const now = Date.now()\n    const candidates: Array<{ key: string; confidence: number }> = []\n\n    for (const pattern of this.accessPatterns.values()) {\n      // 需要足够的访问历史\n      if (pattern.accessCount < this.config.minAccessForPrediction) {\n        continue\n      }\n\n      // 计算预取置信度\n      const timeSinceLastAccess = now - pattern.lastAccess\n      const timeUntilPredicted = pattern.predictedNextAccess - now\n\n      // 如果预测的访问时间即将到来\n      if (timeUntilPredicted > 0 && timeUntilPredicted < pattern.averageInterval * 0.5) {\n        // 趋势递增的项有更高的优先级\n        let confidence = 0.5\n        if (pattern.trend === 'increasing') {\n          confidence = 0.9\n        } else if (pattern.trend === 'stable') {\n          confidence = 0.7\n        } else {\n          confidence = 0.4\n        }\n\n        // 根据访问频率调整置信度\n        if (pattern.accessCount > 10) {\n          confidence += 0.1\n        }\n\n        if (confidence >= this.config.prefetchThreshold) {\n          candidates.push({ key: pattern.key, confidence })\n        }\n      }\n    }\n\n    // 按置信度排序\n    candidates.sort((a, b) => b.confidence - a.confidence)\n\n    return candidates.slice(0, 10).map(c => c.key)\n  }\n\n  /**\n   * 启动预测引擎\n   */\n  private startPredictionEngine(): void {\n    this.predictionTimer = setInterval(() => {\n      const candidates = this.getPrefetchCandidates()\n\n      if (candidates.length > 0) {\n        this.logger?.debug('Predictive prefetch candidates', {\n          count: candidates.length,\n          keys: candidates.slice(0, 3)\n        })\n\n        // 这里可以触发预加载逻辑\n        // 实际实现需要有数据加载器\n      }\n    }, 10000) as any // 每10秒运行一次预测\n  }\n\n  /**\n   * 启动模式清理\n   */\n  private startPatternCleanup(): void {\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupOldPatterns()\n    }, 60000) as any // 每分钟清理一次\n  }\n\n  /**\n   * 清理过期的访问模式\n   */\n  private cleanupOldPatterns(): void {\n    const now = Date.now()\n    const expiredKeys: string[] = []\n\n    for (const [key, pattern] of this.accessPatterns) {\n      // 如果超过时间窗口未访问，删除模式\n      if (now - pattern.lastAccess > this.config.patternWindow) {\n        expiredKeys.push(key)\n      }\n    }\n\n    expiredKeys.forEach(key => this.accessPatterns.delete(key))\n\n    if (expiredKeys.length > 0) {\n      this.logger?.debug('Cleaned old access patterns', {\n        removed: expiredKeys.length\n      })\n    }\n  }\n\n  /**\n   * 获取访问模式统计\n   */\n  getStats(): {\n    totalPatterns: number\n    highFrequency: number\n    mediumFrequency: number\n    lowFrequency: number\n    increasingTrend: number\n    decreasingTrend: number\n  } {\n    const patterns = Array.from(this.accessPatterns.values())\n\n    return {\n      totalPatterns: patterns.length,\n      highFrequency: patterns.filter(p => p.averageInterval < 60000).length,\n      mediumFrequency: patterns.filter(p => p.averageInterval >= 60000 && p.averageInterval < 300000).length,\n      lowFrequency: patterns.filter(p => p.averageInterval >= 300000).length,\n      increasingTrend: patterns.filter(p => p.trend === 'increasing').length,\n      decreasingTrend: patterns.filter(p => p.trend === 'decreasing').length\n    }\n  }\n\n  /**\n   * 销毁智能缓存策略\n   */\n  destroy(): void {\n    if (this.predictionTimer) {\n      clearInterval(this.predictionTimer)\n      this.predictionTimer = undefined\n    }\n\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer)\n      this.cleanupTimer = undefined\n    }\n\n    this.accessPatterns.clear()\n  }\n}\n\n/**\n * 创建智能缓存策略实例\n */\nexport function createSmartCacheStrategy<T = unknown>(\n  cache: CacheManager<T>,\n  config?: SmartCacheConfig,\n  logger?: Logger\n): SmartCacheStrategy<T> {\n  return new SmartCacheStrategy<T>(cache, config, logger)\n}\n\n\n\n\n"],"names":[],"mappings":";;;;;;;;;MAgCa,kBAAA,CAAkB;AAAA,EAM7B,WAAA,CACU,KAAA,EACR,MAAA,GAA2B,IACnB,MAAA,EAAe;AAFf,IAAA,IAAA,CAAA,KAAA,GAAA,KAAA;AAEA,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AARF,IAAA,IAAA,CAAA,cAAA,uBAAqB,GAAA,EAAG;AAU9B,IAAA,IAAA,CAAK,MAAA,GAAS;AAAA,MACZ,qBAAA,EAAuB,OAAO,qBAAA,IAAyB,IAAA;AAAA,MACvD,wBAAA,EAA0B,OAAO,wBAAA,IAA4B,IAAA;AAAA,MAC7D,iBAAA,EAAmB,OAAO,iBAAA,IAAqB,IAAA;AAAA,MAC/C,sBAAA,EAAwB,OAAO,sBAAA,IAA0B,CAAA;AAAA,MACzD,aAAA,EAAe,MAAA,CAAO,aAAA,IAAiB,EAAA,GAAK,EAAA,GAAK,GAAA;AAAA;AAAA,MACjD,iBAAA,EAAmB,OAAO,iBAAA,IAAqB;AAAA;AAIjD,IAAA,IAAI,IAAA,CAAK,OAAO,wBAAA,EAA0B;AACxC,MAAA,IAAA,CAAK,qBAAA,EAAqB;AAAA,IAC5B;AAGA,IAAA,IAAA,CAAK,mBAAA,EAAmB;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,GAAA,EAAW;AACtB,IAAA,IAAI,CAAC,IAAA,CAAK,MAAA,CAAO,qBAAA,EAAuB;AACtC,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,GAAA,GAAM,KAAK,GAAA;AACjB,IAAA,IAAI,OAAA,GAAU,IAAA,CAAK,cAAA,CAAe,GAAA,CAAI,GAAG,CAAA;AAEzC,IAAA,IAAI,CAAC,OAAA,EAAS;AACZ,MAAA,OAAA,GAAU;AAAA,QACR,GAAA;AAAA,QACA,WAAA,EAAa,CAAA;AAAA,QACb,UAAA,EAAY,GAAA;AAAA,QACZ,WAAA,EAAa,GAAA;AAAA,QACb,eAAA,EAAiB,CAAA;AAAA,QACjB,KAAA,EAAO,QAAA;AAAA,QACP,mBAAA,EAAqB;AAAA;AAEvB,MAAA,IAAA,CAAK,cAAA,CAAe,GAAA,CAAI,GAAA,EAAK,OAAO,CAAA;AAAA,IACtC;AAGA,IAAA,MAAM,QAAA,GAAW,MAAM,OAAA,CAAQ,UAAA;AAC/B,IAAA,OAAA,CAAQ,WAAA,EAAA;AACR,IAAA,OAAA,CAAQ,UAAA,GAAa,GAAA;AAGrB,IAAA,IAAI,OAAA,CAAQ,cAAc,CAAA,EAAG;AAC3B,MAAA,OAAA,CAAQ,eAAA,GAAkB,QAAQ,eAAA,KAAoB,CAAA,GAClD,WACA,OAAA,CAAQ,eAAA,GAAkB,MAAM,QAAA,GAAW,GAAA;AAAA,IACjD;AAGA,IAAA,IAAA,CAAK,aAAa,OAAO,CAAA;AAGzB,IAAA,IAAI,OAAA,CAAQ,WAAA,IAAe,IAAA,CAAK,MAAA,CAAO,sBAAA,EAAwB;AAC7D,MAAA,OAAA,CAAQ,mBAAA,GAAsB,MAAM,OAAA,CAAQ,eAAA;AAAA,IAC9C;AAEA,IAAA,IAAA,CAAK,MAAA,EAAQ,KAAA,CAAM,CAAA,2BAAA,EAA8B,GAAG,CAAA,CAAA,EAAI;AAAA,MACtD,OAAO,OAAA,CAAQ,WAAA;AAAA,MACf,QAAA,EAAU,OAAA,CAAQ,eAAA,CAAgB,OAAA,CAAQ,CAAC;AAAA,KAC5C,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKQ,aAAa,OAAA,EAAsB;AACzC,IAAA,IAAI,OAAA,CAAQ,cAAc,CAAA,EAAG;AAC3B,MAAA,OAAA,CAAQ,KAAA,GAAQ,QAAA;AAChB,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,SAAA,GAAY,OAAA,CAAQ,UAAA,GAAa,OAAA,CAAQ,WAAA;AAC/C,IAAA,MAAM,gBAAA,GAAmB,YAAY,OAAA,CAAQ,eAAA;AAC7C,IAAA,MAAM,iBAAiB,OAAA,CAAQ,WAAA;AAE/B,IAAA,MAAM,QAAQ,cAAA,GAAiB,gBAAA;AAE/B,IAAA,IAAI,QAAQ,GAAA,EAAK;AACf,MAAA,OAAA,CAAQ,KAAA,GAAQ,YAAA;AAAA,IAClB,CAAA,MAAA,IAAW,QAAQ,GAAA,EAAK;AACtB,MAAA,OAAA,CAAQ,KAAA,GAAQ,YAAA;AAAA,IAClB,CAAA,MAAO;AACL,MAAA,OAAA,CAAQ,KAAA,GAAQ,QAAA;AAAA,IAClB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,oBAAA,CAAqB,KAAa,UAAA,EAAkB;AAClD,IAAA,IAAI,CAAC,IAAA,CAAK,MAAA,CAAO,iBAAA,EAAmB;AAClC,MAAA,OAAO,UAAA;AAAA,IACT;AAEA,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,cAAA,CAAe,GAAA,CAAI,GAAG,CAAA;AAC3C,IAAA,IAAI,CAAC,OAAA,IAAW,OAAA,CAAQ,WAAA,GAAc,IAAA,CAAK,OAAO,sBAAA,EAAwB;AACxE,MAAA,OAAO,UAAA;AAAA,IACT;AAKA,IAAA,IAAI,OAAA,CAAQ,kBAAkB,GAAA,EAAO;AAEnC,MAAA,OAAO,IAAA,CAAK,GAAA,CAAI,OAAA,CAAQ,eAAA,GAAkB,GAAG,GAAK,CAAA;AAAA,IACpD,CAAA,MAAA,IAAW,OAAA,CAAQ,eAAA,GAAkB,GAAA,EAAQ;AAE3C,MAAA,OAAO,IAAA,CAAK,GAAA,CAAI,OAAA,CAAQ,eAAA,GAAkB,KAAK,GAAK,CAAA;AAAA,IACtD,CAAA,MAAO;AAEL,MAAA,OAAO,KAAK,GAAA,CAAI,OAAA,CAAQ,eAAA,GAAkB,CAAA,EAAG,aAAa,CAAC,CAAA;AAAA,IAC7D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAA,GAAqB;AACnB,IAAA,IAAI,CAAC,IAAA,CAAK,MAAA,CAAO,wBAAA,EAA0B;AACzC,MAAA,OAAO;IACT;AAEA,IAAA,MAAM,GAAA,GAAM,KAAK,GAAA;AACjB,IAAA,MAAM,aAAyD,EAAA;AAE/D,IAAA,KAAA,MAAW,OAAA,IAAW,IAAA,CAAK,cAAA,CAAe,MAAA,EAAM,EAAI;AAElD,MAAA,IAAI,OAAA,CAAQ,WAAA,GAAc,IAAA,CAAK,MAAA,CAAO,sBAAA,EAAwB;AAC5D,QAAA;AAAA,MACF;AAGA,MAA4B,MAAM,OAAA,CAAQ;AAC1C,MAAA,MAAM,kBAAA,GAAqB,QAAQ,mBAAA,GAAsB,GAAA;AAGzD,MAAA,IAAI,kBAAA,GAAqB,CAAA,IAAK,kBAAA,GAAqB,OAAA,CAAQ,kBAAkB,GAAA,EAAK;AAEhF,QAAA,IAAI,UAAA,GAAa,GAAA;AACjB,QAAA,IAAI,OAAA,CAAQ,UAAU,YAAA,EAAc;AAClC,UAAA,UAAA,GAAa,GAAA;AAAA,QACf,CAAA,MAAA,IAAW,OAAA,CAAQ,KAAA,KAAU,QAAA,EAAU;AACrC,UAAA,UAAA,GAAa,GAAA;AAAA,QACf,CAAA,MAAO;AACL,UAAA,UAAA,GAAa,GAAA;AAAA,QACf;AAGA,QAAA,IAAI,OAAA,CAAQ,cAAc,EAAA,EAAI;AAC5B,UAAA,UAAA,IAAc,GAAA;AAAA,QAChB;AAEA,QAAA,IAAI,UAAA,IAAc,IAAA,CAAK,MAAA,CAAO,iBAAA,EAAmB;AAC/C,UAAA,UAAA,CAAW,KAAK,EAAE,GAAA,EAAK,OAAA,CAAQ,GAAA,EAAK,YAAY,CAAA;AAAA,QAClD;AAAA,MACF;AAAA,IACF;AAGA,IAAA,UAAA,CAAW,KAAK,CAAC,CAAA,EAAG,MAAM,CAAA,CAAE,UAAA,GAAa,EAAE,UAAU,CAAA;AAErD,IAAA,OAAO,UAAA,CAAW,MAAM,CAAA,EAAG,EAAE,EAAE,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,GAAG,CAAA;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKQ,qBAAA,GAAqB;AAC3B,IAAA,IAAA,CAAK,eAAA,GAAkB,YAAY,MAAK;AACtC,MAAA,MAAM,UAAA,GAAa,KAAK,qBAAA;AAExB,MAAA,IAAI,UAAA,CAAW,SAAS,CAAA,EAAG;AACzB,QAAA,IAAA,CAAK,MAAA,EAAQ,MAAM,gCAAA,EAAkC;AAAA,UACnD,OAAO,UAAA,CAAW,MAAA;AAAA,UAClB,IAAA,EAAM,UAAA,CAAW,KAAA,CAAM,CAAA,EAAG,CAAC;AAAA,SAC5B,CAAA;AAAA,MAIH;AAAA,IACF,GAAG,GAAK,CAAA;AAAA,EACV;AAAA;AAAA;AAAA;AAAA,EAKQ,mBAAA,GAAmB;AACzB,IAAA,IAAA,CAAK,YAAA,GAAe,YAAY,MAAK;AACnC,MAAA,IAAA,CAAK,kBAAA,EAAkB;AAAA,IACzB,GAAG,GAAK,CAAA;AAAA,EACV;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAA,GAAkB;AACxB,IAAA,MAAM,GAAA,GAAM,KAAK,GAAA;AACjB,IAAA,MAAM,cAAwB,EAAA;AAE9B,IAAA,KAAA,MAAW,CAAC,GAAA,EAAK,OAAO,CAAA,IAAK,KAAK,cAAA,EAAgB;AAEhD,MAAA,IAAI,GAAA,GAAM,OAAA,CAAQ,UAAA,GAAa,IAAA,CAAK,OAAO,aAAA,EAAe;AACxD,QAAA,WAAA,CAAY,KAAK,GAAG,CAAA;AAAA,MACtB;AAAA,IACF;AAEA,IAAA,WAAA,CAAY,QAAQ,CAAA,GAAA,KAAO,IAAA,CAAK,cAAA,CAAe,MAAA,CAAO,GAAG,CAAC,CAAA;AAE1D,IAAA,IAAI,WAAA,CAAY,SAAS,CAAA,EAAG;AAC1B,MAAA,IAAA,CAAK,MAAA,EAAQ,MAAM,6BAAA,EAA+B;AAAA,QAChD,SAAS,WAAA,CAAY;AAAA,OACtB,CAAA;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,QAAA,GAAQ;AAQN,IAAA,MAAM,WAAW,KAAA,CAAM,IAAA,CAAK,IAAA,CAAK,cAAA,CAAe,QAAQ,CAAA;AAExD,IAAA,OAAO;AAAA,MACL,eAAe,QAAA,CAAS,MAAA;AAAA,MACxB,eAAe,QAAA,CAAS,MAAA,CAAO,OAAK,CAAA,CAAE,eAAA,GAAkB,GAAK,CAAA,CAAE,MAAA;AAAA,MAC/D,eAAA,EAAiB,QAAA,CAAS,MAAA,CAAO,CAAA,CAAA,KAAK,CAAA,CAAE,mBAAmB,GAAA,IAAS,CAAA,CAAE,eAAA,GAAkB,GAAM,CAAA,CAAE,MAAA;AAAA,MAChG,cAAc,QAAA,CAAS,MAAA,CAAO,OAAK,CAAA,CAAE,eAAA,IAAmB,GAAM,CAAA,CAAE,MAAA;AAAA,MAChE,iBAAiB,QAAA,CAAS,MAAA,CAAO,OAAK,CAAA,CAAE,KAAA,KAAU,YAAY,CAAA,CAAE,MAAA;AAAA,MAChE,iBAAiB,QAAA,CAAS,MAAA,CAAO,OAAK,CAAA,CAAE,KAAA,KAAU,YAAY,CAAA,CAAE;AAAA;EAEpE;AAAA;AAAA;AAAA;AAAA,EAKA,OAAA,GAAO;AACL,IAAA,IAAI,KAAK,eAAA,EAAiB;AACxB,MAAA,aAAA,CAAc,KAAK,eAAe,CAAA;AAClC,MAAA,IAAA,CAAK,eAAA,GAAkB,MAAA;AAAA,IACzB;AAEA,IAAA,IAAI,KAAK,YAAA,EAAc;AACrB,MAAA,aAAA,CAAc,KAAK,YAAY,CAAA;AAC/B,MAAA,IAAA,CAAK,YAAA,GAAe,MAAA;AAAA,IACtB;AAEA,IAAA,IAAA,CAAK,eAAe,KAAA;EACtB;AACD;SAKe,wBAAA,CACd,KAAA,EACA,MAAA,EACA,MAAA,EAAe;AAEf,EAAA,OAAO,IAAI,kBAAA,CAAsB,KAAA,EAAO,MAAA,EAAQ,MAAM,CAAA;AACxD;;;;"}